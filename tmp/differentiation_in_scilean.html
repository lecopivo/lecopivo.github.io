<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20: https://docutils.sourceforge.io/" />
<title>Differentiation in SciLean</title>
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="document" id="differentiation-in-scilean">
<h1 class="title">Differentiation in SciLean</h1>

<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">import</span> SciLean
<span class="kn">open</span> SciLean</span></pre><p>The backbone of any numerical/scientific/machine learing software is 
an automatic and/or symbolic differentiation. In SciLean, automatic and 
symbolic differentiation is build on top of these two operators:</p>
<ol class="arabic simple">
<li>Differential <code class="highlight coq"><span class="o">∂</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span></code></li>
<li>Adjoint <code class="highlight coq"><span class="o">†:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">Y</span> <span class="o">→</span> <span class="n">X</span><span class="o">)</span></code></li>
</ol>
<p>The differential <code class="highlight coq"><span class="o">∂</span></code> tells us how much does the function <code class="highlight coq"><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="o">→</span> <span class="n">Y</span></code>
changes in the direction <code class="highlight coq"><span class="n">dx</span> <span class="o">:</span> <span class="n">X</span></code> at the point <code class="highlight coq"><span class="n">x</span> <span class="o">:</span> <span class="n">X</span></code>. The usual 
mathematical definition is:</p>
<div class="math">
\begin{equation*}
\partial \texttt{f x dx} := \lim_{h \rightarrow 0} \frac{f(x + dx) - f(x)}{h}
\end{equation*}
</div>
<!--  -->
<p>Because mathlib is not yet ported to Lean 4 this definition is not used
in SciLean. Right now, the differential <code class="highlight coq"><span class="o">∂</span></code> is just postulated to exist.</p>
<p>The adjoint <code class="highlight coq"><span class="o">†</span></code> is just well known matrix transposition. Thus for real
valued matrix <code class="highlight coq"><span class="n">A</span></code></p>
<div class="math">
\begin{equation*}
(A^\dagger)_{ij} = A_{ji}
\end{equation*}
</div>
<!--  -->
<p>For a general linear map <code class="highlight coq"><span class="n">A</span> <span class="o">:</span> <span class="n">X</span> <span class="o">→</span> <span class="n">Y</span></code> between two Hilbert spaces <code class="highlight coq"><span class="n">X</span></code> and <code class="highlight coq"><span class="n">Y</span></code>, 
the adjoint is defined via</p>
<div class="math">
\begin{equation*}
\langle A x, y \rangle = \langle x, A^\dagger y \rangle  \qquad \, \forall x \in X, \,y \in Y
\end{equation*}
</div>
<p>We will show that these two operators give a rise to a whole zoo of operators</p>
<ol class="arabic simple">
<li>Differential <code class="highlight coq"><span class="o">∂</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span></code></li>
<li>Adjoint <code class="highlight coq"><span class="o">†:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">Y</span> <span class="o">→</span> <span class="n">X</span><span class="o">)</span></code></li>
<li>Adjoint Differantial <code class="highlight coq"><span class="o">∂†</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span> <span class="o">→</span> <span class="n">X</span><span class="o">)</span></code></li>
<li>Derivative <code class="highlight coq"><span class="n">ⅆ</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℝ</span> <span class="o">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">ℝ</span> <span class="o">→</span> <span class="n">X</span><span class="o">)</span></code></li>
<li>Gradient <code class="highlight coq"><span class="o">∇</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">ℝ</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">X</span><span class="o">)</span></code></li>
<li>Divergence <code class="highlight coq"><span class="o">∇·</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">ℝ</span><span class="o">)</span></code></li>
<li>Forward Mode AD <code class="highlight coq"><span class="n">fwdDiff</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">X</span><span class="o">×(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">))</span></code></li>
<li>Reverse Mode AD <code class="highlight coq"><span class="n">revDiff</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">X</span><span class="o">×(</span><span class="n">Y</span> <span class="o">→</span> <span class="n">X</span><span class="o">))</span></code></li>
<li>Dual Number AD <code class="highlight coq"><span class="n">dualDiff</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">X</span><span class="o">×</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">×</span><span class="n">Y</span><span class="o">)</span></code></li>
</ol>
<div class="section" id="differential">
<h1>Differential</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">section</span> Differential</span></pre><p>The simples possible example: What is the differential of identity function?</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk0"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">AutoImpl.val (Eq.mpr (_ : (AutoImpl <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> x) <span class="bp">=</span> AutoImpl <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx) AutoImpl.finish) : ℝ <span class="bp">→</span> ℝ <span class="bp">→</span> ℝ</blockquote></div></div></small></span><span class="alectryon-wsp"> (<span class="bp">∂</span> <span class="bp">λ</span> x : ℝ <span class="bp">=&gt;</span> x) 
    rewrite_by</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk1">(</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> x</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk2">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk3">trace_state</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="bp">|</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="differentiation-in-scilean-lean-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk4"> )</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx</div></blockquote></div></div></small></span></pre><p>As expected the change of identity function is just <code class="highlight coq"><span class="n">dx</span></code> and it does not depend
on the position <code class="highlight coq"><span class="n">x</span></code>.</p>
<p>(Note: The SciLean's custom notation <code class="highlight coq"><span class="n">x</span><span class="o">:</span><span class="n">term</span> <span class="n">rewrite_by</span> <span class="n">t</span><span class="o">:</span><span class="n">convSeq</span></code> 
applies tactic <code class="highlight coq"><span class="n">t</span></code> on the term <code class="highlight coq"><span class="n">x</span></code>. This notation confuses the <code class="highlight coq"><span class="o">#</span><span class="n">check</span></code> 
command. To see the actual result it is better to use the <code class="highlight coq"><span class="n">trace_state</span></code> 
tactic. TODO: Add a document explaining the technical detail of <code class="highlight coq"><span class="n">rewrite_by</span></code>
notation. TODO: Add delaborator for terms created with <code class="highlight coq"><span class="n">AutoImpl</span></code>)</p>
<p>Another way to check that the differential is computed correctly</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"> <span class="kd">example</span> : (<span class="bp">∂</span> <span class="bp">λ</span> x : ℝ <span class="bp">=&gt;</span> x) <span class="bp">=</span> (<span class="bp">λ</span> x dx <span class="bp">=&gt;</span> dx) :=</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk5"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> x) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk6">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>This has the disadvantages that we need to know the result beforehand.</p>
<p>Few more basic derivatives: of a constant, quadratic function, sine</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk7"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">AutoImpl.val (Eq.mpr (_ : (AutoImpl <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">1</span>) <span class="bp">=</span> AutoImpl <span class="k">fun</span> y dy <span class="bp">=&gt;</span> <span class="mi">0</span>) AutoImpl.finish) : ℝ <span class="bp">→</span> ℝ <span class="bp">→</span> ℝ</blockquote></div></div></small></span><span class="alectryon-wsp"> (<span class="bp">∂</span> <span class="bp">λ</span> x : ℝ <span class="bp">=&gt;</span> (<span class="mi">1</span> : ℝ)) 
    rewrite_by 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk8">(</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">1</span></div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk9">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> y dy <span class="bp">=&gt;</span> <span class="mi">0</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chka">trace_state</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="bp">|</span> <span class="k">fun</span> y dy <span class="bp">=&gt;</span> <span class="mi">0</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> y dy <span class="bp">=&gt;</span> <span class="mi">0</span></div></blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="differentiation-in-scilean-lean-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chkb">)</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> y dy <span class="bp">=&gt;</span> <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chkc"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">AutoImpl.val
  (Eq.mpr (_ : (AutoImpl <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">*</span> x) <span class="bp">=</span> AutoImpl <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx) AutoImpl.finish) : ℝ <span class="bp">→</span> ℝ <span class="bp">→</span> ℝ</blockquote></div></div></small></span><span class="alectryon-wsp"> (<span class="bp">∂</span> <span class="bp">λ</span> x : ℝ <span class="bp">=&gt;</span> x <span class="bp">*</span> x) 
    rewrite_by 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chkd">(</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chke">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chkf">trace_state</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="bp">|</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="differentiation-in-scilean-lean-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk10">)</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk11"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">AutoImpl.val
  (Eq.mpr (_ : (AutoImpl <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> Math.sin x) <span class="bp">=</span> AutoImpl <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> Math.cos x) AutoImpl.finish) : ℝ <span class="bp">→</span> ℝ <span class="bp">→</span> ℝ</blockquote></div></div></small></span><span class="alectryon-wsp"> (<span class="bp">∂</span> <span class="bp">λ</span> x : ℝ <span class="bp">=&gt;</span> Math.sin x) 
    rewrite_by 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk12">(</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> Math.sin x</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk13">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> Math.cos x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk14">trace_state</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="bp">|</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> Math.cos x</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> Math.cos x</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="differentiation-in-scilean-lean-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk15">)</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> Math.cos x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span></pre><p>The result <code class="highlight coq"><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">dx</span> <span class="o">=&gt;</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">dx</span></code> is slightly undesirable. We 
would like to get <code class="highlight coq"><span class="kr">fun</span> <span class="nv">x</span> <span class="nv">dx</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">x</span></code>. Such algebraic manipulation
is within the scope of mathlib's tactics so we will wait for mathlib
port to Lean 4.</p>
<p>Let's introduce few generic functions  to demonstrate some general differentiation 
results</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">variable</span> {X Y Z : <span class="kt">Type</span>} [Vec X] [Vec Y] [Vec Z]
  <span class="kd">variable</span> (f : Y <span class="bp">→</span> Z) [IsSmooth f]
  <span class="kd">variable</span> (g : X <span class="bp">→</span> Y) [IsSmooth g]</span></pre><p>The most crucial tool when computing derivatives is the chain rule, as a proof</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">example</span> : (<span class="bp">∂</span> <span class="bp">λ</span> x <span class="bp">=&gt;</span> f (g x)) <span class="bp">=</span> (<span class="bp">λ</span> x dx <span class="bp">=&gt;</span> <span class="bp">∂</span> f (g x) (<span class="bp">∂</span> g x dx)) := 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk16"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝³</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> f (g x)) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (g x) (differential g x dx)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk17">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>Or as a symbolic computation</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk18"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">AutoImpl.val
  (Eq.mpr
    (_ : (AutoImpl <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> f (g x)) <span class="bp">=</span> AutoImpl <span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (g x) (differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> g x) x dx))
    AutoImpl.finish) : X <span class="bp">→</span> X <span class="bp">→</span> Z</blockquote></div></div></small></span><span class="alectryon-wsp"> (<span class="bp">∂</span> <span class="bp">λ</span> x <span class="bp">=&gt;</span> f (g x)) 
    rewrite_by 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk19">(</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝³</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> f (g x)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk1a">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝³</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (g x) (differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> g x) x dx)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk1b">trace_state</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">X Y Z : <span class="kt">Type</span>
inst<span class="bp">✝⁴</span> : SciLean.Vec X
inst<span class="bp">✝³</span> : SciLean.Vec Y
inst<span class="bp">✝²</span> : SciLean.Vec Z
f : Y <span class="bp">→</span> Z
: SciLean.IsSmooth f
g : X <span class="bp">→</span> Y
: SciLean.IsSmooth g
<span class="bp">|</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> SciLean.differential f (g x) (SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> g x) x dx)</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝³</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (g x) (differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> g x) x dx)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="differentiation-in-scilean-lean-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk1c">)</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝³</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (g x) (differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> g x) x dx)</div></blockquote></div></div></small></span></pre><p>Another common rule is the product rule</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">variable</span> (ϕ ψ : ℝ <span class="bp">→</span> ℝ) [IsSmooth ϕ] [IsSmooth ψ]

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk1d"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">AutoImpl.val
  (Eq.mpr
    (_ :
      (AutoImpl <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x <span class="bp">*</span> ψ x) <span class="bp">=</span>
        AutoImpl <span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) x dx <span class="bp">*</span> ψ x <span class="bp">+</span> ϕ x <span class="bp">*</span> differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ψ x) x dx)
    AutoImpl.finish) : ℝ <span class="bp">→</span> ℝ <span class="bp">→</span> ℝ</blockquote></div></div></small></span><span class="alectryon-wsp"> (<span class="bp">∂</span> <span class="bp">λ</span> x <span class="bp">=&gt;</span> ϕ x <span class="bp">*</span> ψ x) 
    rewrite_by 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk1e">(</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x <span class="bp">*</span> ψ x</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk1f">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) x dx <span class="bp">*</span> ψ x <span class="bp">+</span> ϕ x <span class="bp">*</span> differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ψ x) x dx</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk20">trace_state</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">X Y Z : <span class="kt">Type</span>
inst<span class="bp">✝⁶</span> : SciLean.Vec X
inst<span class="bp">✝⁵</span> : SciLean.Vec Y
inst<span class="bp">✝⁴</span> : SciLean.Vec Z
f : Y <span class="bp">→</span> Z
: SciLean.IsSmooth f
g : X <span class="bp">→</span> Y
: SciLean.IsSmooth g
ϕ ψ : ℝ <span class="bp">→</span> ℝ
: SciLean.IsSmooth ϕ
: SciLean.IsSmooth ψ
<span class="bp">|</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) x dx <span class="bp">*</span> ψ x <span class="bp">+</span> ϕ x <span class="bp">*</span> SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ψ x) x dx</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) x dx <span class="bp">*</span> ψ x <span class="bp">+</span> ϕ x <span class="bp">*</span> differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ψ x) x dx</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="differentiation-in-scilean-lean-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk21">)</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) x dx <span class="bp">*</span> ψ x <span class="bp">+</span> ϕ x <span class="bp">*</span> differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ψ x) x dx</div></blockquote></div></div></small></span></pre><div class="section" id="derivative">
<h2>Derivative</h2>
<p>The standard notion of derivative takes a function from reals to reals, <code class="highlight coq"><span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">→</span> <span class="n">ℝ</span></code>,
and produces again a function from, usually denoted with <code class="highlight coq"><span class="n">f'</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="o">→</span> <span class="n">ℝ</span></code>.</p>
<p>The differential <code class="highlight coq"><span class="o">∂</span></code> does not fit this. The well know result that 
derivative of exponential is exponential <code class="highlight coq"><span class="n">exp'</span> <span class="o">=</span> <span class="n">exp</span></code> can't be expressed as 
easily with differential.</p>
<p>The naive statement does not even typecheck</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="bp">#</span>check_failure</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk22"><span class="bp">∂</span> Math.exp <span class="bp">=</span> Math.exp</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: type mismatch
  Math.exp
has type
  ℝ <span class="bp">→</span> ℝ : <span class="kt">Type</span>
but is expected to <span class="k">have</span> type
  ℝ <span class="bp">→</span> ℝ <span class="bp">→</span> ℝ : <span class="kt">Type</span></blockquote></div></div></small><span class="alectryon-wsp"> </span></span></pre><p>The <code class="highlight coq"><span class="n">exp'</span> <span class="o">=</span> <span class="n">exp</span></code> is this slightly cumbersome statement</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">example</span> : (<span class="bp">λ</span> t <span class="bp">=&gt;</span> <span class="bp">∂</span> Math.exp t <span class="mi">1</span>) <span class="bp">=</span> Math.exp :=</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk23"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> t <span class="bp">=&gt;</span> differential Math.exp t <span class="mi">1</span>) <span class="bp">=</span> Math.exp</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk24">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>For this reason we introduce a new operator, derivative <code class="highlight coq"><span class="n">ⅆ</span> <span class="o">:</span> <span class="o">(</span><span class="n">ℝ</span> <span class="o">→</span> <span class="n">X</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">ℝ</span> <span class="o">→</span> <span class="n">X</span><span class="o">)</span></code>.
Which is defines as follows</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">example</span> (f : ℝ <span class="bp">→</span> X) : ⅆ f <span class="bp">=</span> <span class="bp">λ</span> t <span class="bp">=&gt;</span> <span class="bp">∂</span> f t <span class="mi">1</span> := 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk25"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unsolved goals
X Y Z : <span class="kt">Type</span>
inst<span class="bp">✝⁶</span> : Vec X
inst<span class="bp">✝⁵</span> : Vec Y
inst<span class="bp">✝⁴</span> : Vec Z
f<span class="bp">✝</span> : Y <span class="bp">→</span> Z
: IsSmooth f<span class="bp">✝</span>
g : X <span class="bp">→</span> Y
: IsSmooth g
ϕ ψ : ℝ <span class="bp">→</span> ℝ
: IsSmooth ϕ
: IsSmooth ψ
f : ℝ <span class="bp">→</span> X
<span class="bp">⊢</span> instDerivativeForAllℝ.dn <span class="mi">1</span> f <span class="bp">=</span> <span class="k">fun</span> t <span class="bp">=&gt;</span> differential f t <span class="mi">1</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f✝</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">derivative <span class="mi">1</span> f <span class="bp">=</span> <span class="k">fun</span> t <span class="bp">=&gt;</span> differential f t <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk26">simp[derivative]</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unsolved goals
X Y Z : <span class="kt">Type</span>
inst<span class="bp">✝⁶</span> : Vec X
inst<span class="bp">✝⁵</span> : Vec Y
inst<span class="bp">✝⁴</span> : Vec Z
f<span class="bp">✝</span> : Y <span class="bp">→</span> Z
: IsSmooth f<span class="bp">✝</span>
g : X <span class="bp">→</span> Y
: IsSmooth g
ϕ ψ : ℝ <span class="bp">→</span> ℝ
: IsSmooth ϕ
: IsSmooth ψ
f : ℝ <span class="bp">→</span> X
<span class="bp">⊢</span> instDerivativeForAllℝ.dn <span class="mi">1</span> f <span class="bp">=</span> <span class="k">fun</span> t <span class="bp">=&gt;</span> differential f t <span class="mi">1</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f✝</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">instDerivativeForAllℝ.dn <span class="mi">1</span> f <span class="bp">=</span> <span class="k">fun</span> t <span class="bp">=&gt;</span> differential f t <span class="mi">1</span></div></blockquote></div></div></small></span></pre><p>Now we have</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">example</span> : ⅆ Math.exp <span class="bp">=</span> Math.exp :=</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk27"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unsolved goals
X Y Z : <span class="kt">Type</span>
inst<span class="bp">✝⁶</span> : Vec X
inst<span class="bp">✝⁵</span> : Vec Y
inst<span class="bp">✝⁴</span> : Vec Z
f : Y <span class="bp">→</span> Z
: IsSmooth f
g : X <span class="bp">→</span> Y
: IsSmooth g
ϕ ψ : ℝ <span class="bp">→</span> ℝ
: IsSmooth ϕ
: IsSmooth ψ
<span class="bp">⊢</span> instDerivativeForAllℝ.dn <span class="mi">1</span> Math.exp <span class="bp">=</span> Math.exp</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">derivative <span class="mi">1</span> Math.exp <span class="bp">=</span> Math.exp</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk28">simp[derivative]</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Error: unsolved goals
X Y Z : <span class="kt">Type</span>
inst<span class="bp">✝⁶</span> : Vec X
inst<span class="bp">✝⁵</span> : Vec Y
inst<span class="bp">✝⁴</span> : Vec Z
f : Y <span class="bp">→</span> Z
: IsSmooth f
g : X <span class="bp">→</span> Y
: IsSmooth g
ϕ ψ : ℝ <span class="bp">→</span> ℝ
: IsSmooth ϕ
: IsSmooth ψ
<span class="bp">⊢</span> instDerivativeForAllℝ.dn <span class="mi">1</span> Math.exp <span class="bp">=</span> Math.exp</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">instDerivativeForAllℝ.dn <span class="mi">1</span> Math.exp <span class="bp">=</span> Math.exp</div></blockquote></div></div></small></span></pre><p>(TODO: Right now simplifier needs to unfold <code class="highlight coq"><span class="n">derivative</span></code>. Fix it!)</p>
<p>We provide convenient notation, <code class="highlight coq"><span class="n">ⅆ</span> <span class="n">t</span><span class="o">,</span> <span class="n">f</span> <span class="n">t</span></code> and <code class="highlight coq"><span class="n">ⅆ</span> <span class="o">(</span><span class="n">t</span><span class="o">:=</span><span class="n">t₀</span><span class="o">),</span> <span class="n">f</span> <span class="n">t</span></code>, for
taking derivative with a respect to an explicit variable.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kn">section</span> DerivativeNotation

    <span class="kd">variable</span> (f : ℝ <span class="bp">→</span> X) (t₀ : ℝ)

    <span class="c1">-- effectively translates `t,` to `λ t =&gt;`</span>
    <span class="kd">example</span> : (ⅆ t, f t) <span class="bp">=</span> ⅆ (<span class="bp">λ</span> t <span class="bp">=&gt;</span> f t ) :=</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk29"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f✝</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> X</span></span></span><br><span><var>t₀</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(derivative <span class="mi">1</span> <span class="k">fun</span> t <span class="bp">=&gt;</span> f t) <span class="bp">=</span> derivative <span class="mi">1</span> <span class="k">fun</span> t <span class="bp">=&gt;</span> f t</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk2a">rfl</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c1">-- similar as above but also applies `t₀` </span>
    <span class="kd">example</span> : (ⅆ (t:=t₀), f t) <span class="bp">=</span> ⅆ (<span class="bp">λ</span> t <span class="bp">=&gt;</span> f t) t₀ :=</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk2b"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f✝</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> X</span></span></span><br><span><var>t₀</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">derivative <span class="mi">1</span> (<span class="k">fun</span> t <span class="bp">=&gt;</span> f t) t₀ <span class="bp">=</span> derivative <span class="mi">1</span> (<span class="k">fun</span> t <span class="bp">=&gt;</span> f t) t₀</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk2c">rfl</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="kd">end</span> DerivativeNotation</span></pre><!--  -->
<p>The notation <code class="highlight coq"><span class="n">ⅆ</span> <span class="o">(</span><span class="n">t</span><span class="o">:=</span><span class="n">t₀</span><span class="o">),</span> <span class="n">f</span> <span class="n">t</span></code> tries to mimick the mathematical notation</p>
<div class="math">
\begin{equation*}
\frac{d}{dt}\bigg\rvert_{t=t_0} f(t)
\end{equation*}
</div>
</div>
<div class="section" id="debugging-differentiation">
<h2>Debugging Differentiation</h2>
<p>Sometimes the differentiation is not doing what we expect. It is crucial
to know how to figure out what went wrong.</p>
<p>To demonstrate this, let's introduce a function <code class="highlight coq"><span class="n">h</span></code> but without the smoothenss
proof i.e. we do not introduce <code class="highlight coq"><span class="o">[</span><span class="n">IsSmooth</span> <span class="n">h</span><span class="o">]</span></code></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">variable</span> (h : X <span class="bp">→</span> Y)</span></pre><p>Now the chain rule for <code class="highlight coq"><span class="n">f</span></code> and <code class="highlight coq"><span class="n">h</span></code> fails</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk2d"><span class="kd">example</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: declaration uses <span class="bp">&#39;</span><span class="gr">sorry</span><span class="bp">&#39;</span></blockquote></div></div></small></span><span class="alectryon-wsp"> : (<span class="bp">∂</span> <span class="bp">λ</span> x <span class="bp">=&gt;</span> f (h x)) <span class="bp">=</span> (<span class="bp">λ</span> x dx <span class="bp">=&gt;</span> <span class="bp">∂</span> f (h x) (<span class="bp">∂</span> h x dx)) := 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk2e"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> f (h x)) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (h x) (differential h x dx)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk2f">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> f (h x)) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (h x) (differential h x dx)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk30">   <span class="c1">-- no progress</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> f (h x)) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (h x) (differential h x dx)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk31"><span class="gr">admit</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp">  <span class="c1">-- we have to give up</span></span></pre><p>We have to use the <code class="highlight coq"><span class="nb">admit</span></code> tactic to close the goal as <code class="highlight coq"><span class="n">simp</span></code> is unable 
to do it right now.</p>
<p>The problem is that <code class="highlight coq"><span class="n">simp</span></code> can't apply chain rule because it is missing
the proof of smoothenss of <code class="highlight coq"><span class="n">h</span></code>. To figure this out, we turn on the option
<code class="highlight coq"><span class="n">trace</span><span class="o">.</span><span class="n">Meta</span><span class="o">.</span><span class="n">Tactic</span><span class="o">.</span><span class="n">simp</span><span class="o">.</span><span class="n">discharge</span></code></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">set_option</span> trace.Meta.Tactic.simp.discharge true <span class="k">in</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk32"><span class="kd">example</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Warning: declaration uses <span class="bp">&#39;</span><span class="gr">sorry</span><span class="bp">&#39;</span></blockquote></div></div></small></span><span class="alectryon-wsp"> : (<span class="bp">∂</span> <span class="bp">λ</span> x <span class="bp">=&gt;</span> f (h x)) <span class="bp">=</span> (<span class="bp">λ</span> x dx <span class="bp">=&gt;</span> <span class="bp">∂</span> f (h x) (<span class="bp">∂</span> h x dx)) := 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk33"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> f (h x)) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (h x) (differential h x dx)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk34">simp</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Meta.Tactic.simp.discharge] SciLean.diff_of_comp, failed to synthesize <span class="kd">instance</span>
      SciLean.IsSmooth <span class="k">fun</span> x <span class="bp">=&gt;</span> h x
[Meta.Tactic.simp.discharge] SciLean.SmoothMap.mk.arg_f.diff_simp, failed to synthesize <span class="kd">instance</span>
      SciLean.IsSmooth <span class="k">fun</span> x <span class="bp">=&gt;</span> f (h x)
[Meta.Tactic.simp.discharge] SciLean.LinMap.mk.arg_f.diff_simp, failed to synthesize <span class="kd">instance</span>
      SciLean.IsLin <span class="k">fun</span> x <span class="bp">=&gt;</span> f (h x)
[Meta.Tactic.simp.discharge] SciLean.SmoothMap.mk.arg_f.diff_simp, failed to synthesize <span class="kd">instance</span>
      SciLean.IsSmooth h
[Meta.Tactic.simp.discharge] SciLean.LinMap.mk.arg_f.diff_simp, failed to synthesize <span class="kd">instance</span>
      SciLean.IsLin h
[Meta.Tactic.simp.discharge] SciLean.LinMap.mk.arg_f.diff_simp, failed to synthesize <span class="kd">instance</span> SciLean.IsLin f</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> f (h x)) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (h x) (differential h x dx)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk35"><span class="gr">admit</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>If you click on <code class="highlight coq"><span class="n">simp</span></code>, one of the messages will be</p>
<pre class="literal-block">
[Meta.Tactic.simp.discharge] SciLean.diff_of_comp, failed to synthesize instance
    SciLean.IsSmooth fun x =&gt; h x
</pre>
<p>(TODO: currently there is tons of crap that should not be there)</p>
<p>If we provide the smoothenss proof we can observe all rewrites by turning on
<code class="highlight coq"><span class="n">trace</span><span class="o">.</span><span class="n">Meta</span><span class="o">.</span><span class="n">Tactic</span><span class="o">.</span><span class="n">simp</span><span class="o">.</span><span class="nb">rewrite</span></code></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">variable</span> [IsSmooth h]

  <span class="kd">set_option</span> trace.Meta.Tactic.simp.rewrite true <span class="k">in</span>
  <span class="kd">example</span> : (<span class="bp">∂</span> <span class="bp">λ</span> x <span class="bp">=&gt;</span> f (h x)) <span class="bp">=</span> (<span class="bp">λ</span> x dx <span class="bp">=&gt;</span> <span class="bp">∂</span> f (h x) (<span class="bp">∂</span> h x dx)) := 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk36"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> f (h x)) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> differential f (h x) (differential h x dx)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk37">simp</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Meta.Tactic.simp.rewrite] SciLean.diff_of_comp:<span class="mi">99</span>, <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span>
      f (h x) <span class="bp">==&gt;</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> SciLean.differential f (h x) (SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> h x) x dx)
[Meta.Tactic.simp.rewrite] eq_self:<span class="mi">1000</span>, (<span class="k">fun</span> x dx <span class="bp">=&gt;</span>
        SciLean.differential f (h x) (SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> h x) x dx)) <span class="bp">=</span>
      <span class="k">fun</span> x dx <span class="bp">=&gt;</span> SciLean.differential f (h x) (SciLean.differential h x dx) <span class="bp">==&gt;</span> True</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>Now <code class="highlight coq"><span class="n">simp</span></code> shows the application of the chain rule</p>
<pre class="literal-block">
[Meta.Tactic.simp.rewrite] SciLean.diff_of_comp:99, ∂fun x =&gt;
      f (h x) ==&gt; fun x dx =&gt; SciLean.differential f (h x) (SciLean.differential (fun x =&gt; h x) x dx)
</pre>
<p>A bit more complicated computation</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">set_option</span> trace.Meta.Tactic.simp.rewrite true <span class="k">in</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk38"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">AutoImpl.val
  (Eq.mpr
    (_ :
      (AutoImpl <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x) <span class="bp">+</span> x) <span class="bp">=</span>
        AutoImpl <span class="k">fun</span> x dx <span class="bp">=&gt;</span> (dx <span class="bp">+</span> x <span class="bp">*</span> (dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx)) <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x) <span class="bp">+</span> dx)
    AutoImpl.finish) : ℝ <span class="bp">→</span> ℝ <span class="bp">→</span> ℝ</blockquote></div></div></small></span><span class="alectryon-wsp"> (<span class="bp">∂</span> <span class="bp">λ</span> x : ℝ <span class="bp">=&gt;</span> x <span class="bp">*</span> Math.exp (x<span class="bp">*</span>x) <span class="bp">+</span> x) 
    rewrite_by 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk39">(</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x) <span class="bp">+</span> x</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk3a">simp</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Meta.Tactic.simp.rewrite] SciLean.diff_of_diag:<span class="mi">98</span>, <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span>
      x <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x) <span class="bp">+</span>
        x <span class="bp">==&gt;</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span>
      SciLean.differential HAdd.hAdd (x <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x)) (SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x)) x dx)
          x <span class="bp">+</span>
        SciLean.differential (HAdd.hAdd (x <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x))) x (SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> x) x dx)
[Meta.Tactic.simp.rewrite] SciLean.HAdd.hAdd.arg_x.diff_simp:<span class="mi">1000</span>, <span class="bp">∂</span>HAdd.hAdd <span class="bp">==&gt;</span> <span class="k">fun</span> x dx y <span class="bp">=&gt;</span> dx
[Meta.Tactic.simp.rewrite] SciLean.diff_of_diag:<span class="mi">98</span>, <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span>
      x <span class="bp">*</span>
        Math.exp
          (x <span class="bp">*</span>
            x) <span class="bp">==&gt;</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span>
      SciLean.differential HMul.hMul x (SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> x) x dx) (Math.exp (x <span class="bp">*</span> x)) <span class="bp">+</span>
        SciLean.differential (HMul.hMul x) (Math.exp (x <span class="bp">*</span> x)) (SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> Math.exp (x <span class="bp">*</span> x)) x dx)
[Meta.Tactic.simp.rewrite] SciLean.HMul.hMul.arg_x.diff_simp:<span class="mi">1000</span>, <span class="bp">∂</span>HMul.hMul <span class="bp">==&gt;</span> SciLean.AutoImpl.val
      (Eq.mpr (_ : (SciLean.AutoImpl <span class="bp">∂</span><span class="k">fun</span> x y <span class="bp">=&gt;</span> x <span class="bp">*</span> y) <span class="bp">=</span> SciLean.AutoImpl <span class="k">fun</span> x dx y <span class="bp">=&gt;</span> dx <span class="bp">*</span> y)
        SciLean.AutoImpl.finish)
[Meta.Tactic.simp.rewrite] SciLean.id.arg_x.diff_simp:<span class="mi">1000</span>, <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">==&gt;</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx
[Meta.Tactic.simp.rewrite] SciLean.AutoImpl.normalize_val:<span class="mi">1000</span>, SciLean.AutoImpl.val
      (Eq.mpr (_ : (SciLean.AutoImpl <span class="bp">∂</span><span class="k">fun</span> x y <span class="bp">=&gt;</span> x <span class="bp">*</span> y) <span class="bp">=</span> SciLean.AutoImpl <span class="k">fun</span> x dx y <span class="bp">=&gt;</span> dx <span class="bp">*</span> y)
        SciLean.AutoImpl.finish) <span class="bp">==&gt;</span> <span class="k">fun</span> x dx y <span class="bp">=&gt;</span> dx <span class="bp">*</span> y
[Meta.Tactic.simp.rewrite] SciLean.HMul.hMul.arg_y.diff_simp:<span class="mi">1000</span>, <span class="bp">∂</span>(HMul.hMul
        x) <span class="bp">==&gt;</span> SciLean.AutoImpl.val
      (Eq.mpr (_ : (SciLean.AutoImpl <span class="bp">∂</span><span class="k">fun</span> y <span class="bp">=&gt;</span> x <span class="bp">*</span> y) <span class="bp">=</span> SciLean.AutoImpl <span class="k">fun</span> x_1 dx <span class="bp">=&gt;</span> x <span class="bp">*</span> dx) SciLean.AutoImpl.finish)
[Meta.Tactic.simp.rewrite] SciLean.diff_of_comp:<span class="mi">99</span>, <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span>
      Math.exp
        (x <span class="bp">*</span> x) <span class="bp">==&gt;</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> SciLean.differential Math.exp (x <span class="bp">*</span> x) (SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">*</span> x) x dx)
[Meta.Tactic.simp.rewrite] SciLean.diff_of_diag:<span class="mi">98</span>, <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span>
      x <span class="bp">*</span>
        x <span class="bp">==&gt;</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span>
      SciLean.differential HMul.hMul x (SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> x) x dx) x <span class="bp">+</span>
        SciLean.differential (HMul.hMul x) x (SciLean.differential (<span class="k">fun</span> x <span class="bp">=&gt;</span> x) x dx)
[Meta.Tactic.simp.rewrite] SciLean.HMul.hMul.arg_x.diff_simp:<span class="mi">1000</span>, <span class="bp">∂</span>HMul.hMul <span class="bp">==&gt;</span> SciLean.AutoImpl.val
      (Eq.mpr (_ : (SciLean.AutoImpl <span class="bp">∂</span><span class="k">fun</span> x y <span class="bp">=&gt;</span> x <span class="bp">*</span> y) <span class="bp">=</span> SciLean.AutoImpl <span class="k">fun</span> x dx y <span class="bp">=&gt;</span> dx <span class="bp">*</span> y)
        SciLean.AutoImpl.finish)
[Meta.Tactic.simp.rewrite] SciLean.AutoImpl.normalize_val:<span class="mi">1000</span>, SciLean.AutoImpl.val
      (Eq.mpr (_ : (SciLean.AutoImpl <span class="bp">∂</span><span class="k">fun</span> x y <span class="bp">=&gt;</span> x <span class="bp">*</span> y) <span class="bp">=</span> SciLean.AutoImpl <span class="k">fun</span> x dx y <span class="bp">=&gt;</span> dx <span class="bp">*</span> y)
        SciLean.AutoImpl.finish) <span class="bp">==&gt;</span> <span class="k">fun</span> x dx y <span class="bp">=&gt;</span> dx <span class="bp">*</span> y
[Meta.Tactic.simp.rewrite] SciLean.HMul.hMul.arg_y.diff_simp:<span class="mi">1000</span>, <span class="bp">∂</span>(HMul.hMul
        x) <span class="bp">==&gt;</span> SciLean.AutoImpl.val
      (Eq.mpr (_ : (SciLean.AutoImpl <span class="bp">∂</span><span class="k">fun</span> y <span class="bp">=&gt;</span> x <span class="bp">*</span> y) <span class="bp">=</span> SciLean.AutoImpl <span class="k">fun</span> x_1 dx <span class="bp">=&gt;</span> x <span class="bp">*</span> dx) SciLean.AutoImpl.finish)
[Meta.Tactic.simp.rewrite] SciLean.AutoImpl.normalize_val:<span class="mi">1000</span>, SciLean.AutoImpl.val
      (Eq.mpr (_ : (SciLean.AutoImpl <span class="bp">∂</span><span class="k">fun</span> y <span class="bp">=&gt;</span> x <span class="bp">*</span> y) <span class="bp">=</span> SciLean.AutoImpl <span class="k">fun</span> x_1 dx <span class="bp">=&gt;</span> x <span class="bp">*</span> dx)
        SciLean.AutoImpl.finish) <span class="bp">==&gt;</span> <span class="k">fun</span> x_1 dx <span class="bp">=&gt;</span> x <span class="bp">*</span> dx
[Meta.Tactic.simp.rewrite] SciLean.Math.exp.arg_x.diff_simp:<span class="mi">1000</span>, <span class="bp">∂</span>Math.exp <span class="bp">==&gt;</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> Math.exp x
[Meta.Tactic.simp.rewrite] SciLean.AutoImpl.normalize_val:<span class="mi">1000</span>, SciLean.AutoImpl.val
      (Eq.mpr (_ : (SciLean.AutoImpl <span class="bp">∂</span><span class="k">fun</span> y <span class="bp">=&gt;</span> x <span class="bp">*</span> y) <span class="bp">=</span> SciLean.AutoImpl <span class="k">fun</span> x_1 dx <span class="bp">=&gt;</span> x <span class="bp">*</span> dx)
        SciLean.AutoImpl.finish) <span class="bp">==&gt;</span> <span class="k">fun</span> x_1 dx <span class="bp">=&gt;</span> x <span class="bp">*</span> dx
[Meta.Tactic.simp.rewrite] SciLean.VecSimps.smul_smul_mul:<span class="mi">1000</span>, x <span class="bp">*</span>
      ((dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx) <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x)) <span class="bp">==&gt;</span> x <span class="bp">*</span> (dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx) <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x)
[Meta.Tactic.simp.rewrite] SciLean.VecSimps.add_same_1:<span class="mi">1000</span>, dx <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x) <span class="bp">+</span>
      x <span class="bp">*</span> (dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx) <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x) <span class="bp">==&gt;</span> (dx <span class="bp">+</span> x <span class="bp">*</span> (dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx)) <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x)
[Meta.Tactic.simp.rewrite] SciLean.HAdd.hAdd.arg_y.diff_simp:<span class="mi">1000</span>, <span class="bp">∂</span>(HAdd.hAdd
        (x <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x))) <span class="bp">==&gt;</span> <span class="k">fun</span> y dy <span class="bp">=&gt;</span> dy
[Meta.Tactic.simp.rewrite] SciLean.LinMap.mk.arg_f.diff_simp:<span class="mi">1000</span>, <span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">==&gt;</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> (dx <span class="bp">+</span> x <span class="bp">*</span> (dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx)) <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x) <span class="bp">+</span> dx</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk3b">trace_state</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">X Y Z : <span class="kt">Type</span>
inst<span class="bp">✝⁷</span> : SciLean.Vec X
inst<span class="bp">✝⁶</span> : SciLean.Vec Y
inst<span class="bp">✝⁵</span> : SciLean.Vec Z
f : Y <span class="bp">→</span> Z
: SciLean.IsSmooth f
g : X <span class="bp">→</span> Y
: SciLean.IsSmooth g
ϕ ψ : ℝ <span class="bp">→</span> ℝ
: SciLean.IsSmooth ϕ
: SciLean.IsSmooth ψ
h : X <span class="bp">→</span> Y
: SciLean.IsSmooth h
<span class="bp">|</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> (dx <span class="bp">+</span> x <span class="bp">*</span> (dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx)) <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x) <span class="bp">+</span> dx</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> (dx <span class="bp">+</span> x <span class="bp">*</span> (dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx)) <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x) <span class="bp">+</span> dx</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="differentiation-in-scilean-lean-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk3c">)</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Vec X</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Vec Y</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Vec Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>ϕ, ψ</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> ℝ</span></span></span><br><span><var>h</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> (dx <span class="bp">+</span> x <span class="bp">*</span> (dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx)) <span class="bp">*</span> Math.exp (x <span class="bp">*</span> x) <span class="bp">+</span> dx</div></blockquote></div></div></small></span></pre><p>Clicking on <code class="highlight coq"><span class="n">simp</span></code> reveals fairly long list of rewrites.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kd">end</span> Differential</span></pre></div>
</div>
<div class="section" id="defining-differentiable-function">
<h1>Defining Differentiable Function</h1>
<p>Sometimes we want to define our own differentiable functions</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kd">def</span> square (x : ℝ) := x <span class="bp">*</span> x</span></pre><p>We might be surprized that differentiating this function does not work</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kd">example</span> : (<span class="bp">∂</span> square) <span class="bp">=</span> (<span class="bp">λ</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx) :=
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk3d"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span>square <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk3e">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span>square <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk3f">  <span class="c1">-- this does nothing as we know nothing about `square`</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span>square <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk40">unfold square</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="bp">∂</span><span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">*</span> x) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk41">  <span class="c1">-- unfold definition of `square`</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span>square <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk42">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp">  <span class="c1">-- now it works</span></span></pre><p>Manually unfolding every definition can get tedious. To circumvent that, 
we can anotate the definition of <code class="highlight coq"><span class="n">square</span></code> to indicate that it is 
differentiable.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kd">def</span> square_v1 (x : ℝ) : ℝ := x <span class="bp">*</span> x
argument x
  isSmooth, diff</span></pre><p>(TODO: When using <code class="highlight coq"><span class="n">def</span></code> with annotations, we <strong>have to</strong> explicitely specify 
the return type. Remove this limitation or add a warrning when the
return type is missing.)</p>
<p>The <code class="highlight coq"><span class="n">argument</span> <span class="n">x</span></code> specifies that everything that follows concerns the 
argument <code class="highlight coq"><span class="n">x</span></code>. The <code class="highlight coq"><span class="n">isSmooth</span></code> generates proof that <code class="highlight coq"><span class="n">square_v1</span></code> is 
smooth in the argument <code class="highlight coq"><span class="n">x</span></code> and <code class="highlight coq"><span class="n">diff</span></code> defines a new function 
<code class="highlight coq"><span class="n">square_v1</span><span class="o">.</span><span class="n">arg_x</span><span class="o">.</span><span class="n">diff</span></code> that is the function's differential.</p>
<p>There are few variants that are usefull when full automation fails or
produces undesirable results.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kd">def</span> square_v2 (x : ℝ) : ℝ := x <span class="bp">*</span> x
argument x
  <span class="c1">-- specify how to prove smoothenss</span>
  isSmooth :=</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk43"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmooth <span class="k">fun</span> x <span class="bp">=&gt;</span> square_v2 x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk44">unfold square_v2</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmooth <span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk45">infer_instance</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp">,
  <span class="c1">-- specify what the differential is and how to prove it</span>
  diff := <span class="mi">2</span> <span class="bp">*</span> dx <span class="bp">*</span> x <span class="kd">by</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk46">simp[diff, square_v2]</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> dx <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk47">funext x dx</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, dx</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.h</span></span><div class="goal-conclusion">dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx <span class="bp">=</span> <span class="mi">2</span> <span class="bp">*</span> dx <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk48">ring</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="kd">def</span> square_v3 (x : ℝ) : ℝ := x <span class="bp">*</span> x
argument x
  <span class="c1">-- proof is done automatically</span>
  isSmooth,
  <span class="c1">-- specify how to compute differential</span>
  diff <span class="kd">by</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk49">simp[square_v3]</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small></span></pre><p>Defining a new function, <code class="highlight coq"><span class="n">square_v1</span><span class="o">.</span><span class="n">arg_x</span><span class="o">.</span><span class="n">diff</span></code> for the differential 
can be undesirable. Sometimes we want <code class="highlight coq"><span class="o">∂</span> <span class="n">square</span></code> to directly simplify
to <code class="highlight coq"><span class="kr">λ</span> <span class="nv">x</span> <span class="nv">dx</span> <span class="o">=&gt;</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">dx</span></code>. To achieve this, we use <code class="highlight coq"><span class="n">diff_simp</span></code>
instead of <code class="highlight coq"><span class="n">diff</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kd">def</span> square_v4 (x : ℝ) : ℝ := x <span class="bp">*</span> x
argument x
  isSmooth,
  diff_simp <span class="kd">by</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk4a">simp[square_v4]</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small></span></pre><p>The <code class="highlight coq"><span class="n">diff_simp</span></code> annotation allows the same variants as <code class="highlight coq"><span class="n">diff</span></code>.</p>
<p>Proof that the second derivative is <code class="highlight coq"><span class="mi">2</span></code>. We have to do manual unfolding 
when working with <code class="highlight coq"><span class="n">square_v3</span></code> but with <code class="highlight coq"><span class="n">square_v4</span></code> the proof is immediate</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kd">example</span> : (<span class="bp">λ</span> x <span class="bp">=&gt;</span> <span class="bp">∂</span> <span class="bp">∂</span> square_v2 x <span class="mi">1</span> <span class="mi">1</span>) <span class="bp">=</span> (<span class="bp">λ</span> x <span class="bp">=&gt;</span> <span class="mi">2</span>) := 
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk4b"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x <span class="bp">=&gt;</span> differential (<span class="bp">∂</span>square_v2) x <span class="mi">1</span> <span class="mi">1</span>) <span class="bp">=</span> <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk4c">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x <span class="bp">=&gt;</span> differential square_v2.arg_x.diff x <span class="mi">1</span> <span class="mi">1</span>) <span class="bp">=</span> <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span></div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk4d">  <span class="c1">-- simp gets stopped on `square_v3.arg_x.diff`</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x <span class="bp">=&gt;</span> differential (<span class="bp">∂</span>square_v2) x <span class="mi">1</span> <span class="mi">1</span>) <span class="bp">=</span> <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk4e">unfold square_v2.arg_x.diff</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x <span class="bp">=&gt;</span> differential (<span class="k">fun</span> x dx <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> dx <span class="bp">*</span> x) x <span class="mi">1</span> <span class="mi">1</span>) <span class="bp">=</span> <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span></div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk4f"> <span class="c1">-- manually unfold definition</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x <span class="bp">=&gt;</span> differential (<span class="bp">∂</span>square_v2) x <span class="mi">1</span> <span class="mi">1</span>) <span class="bp">=</span> <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk50">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp">  <span class="c1">-- we can continue with computation</span>

<span class="kd">example</span> : (<span class="bp">λ</span> x <span class="bp">=&gt;</span> <span class="bp">∂</span> <span class="bp">∂</span> square_v4 x <span class="mi">1</span> <span class="mi">1</span>) <span class="bp">=</span> (<span class="bp">λ</span> x <span class="bp">=&gt;</span> <span class="mi">2</span>) := 
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk51"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x <span class="bp">=&gt;</span> differential (<span class="bp">∂</span>square_v4) x <span class="mi">1</span> <span class="mi">1</span>) <span class="bp">=</span> <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk52">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp">  <span class="c1">-- done immediately</span></span></pre><p>We missed our chance to add annotations to the original function <code class="highlight coq"><span class="n">square</span></code>.
We can add additional annotations later on with <code class="highlight coq"><span class="n">function_properties</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">function_properties square (x : ℝ) : ℝ  
argument x
  isSmooth, diff_simp

<span class="c1">-- now we can differentiate `square`</span>
<span class="kd">example</span> : <span class="bp">∂</span> square <span class="bp">=</span> <span class="bp">λ</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx :=</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk53"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span>square <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk54">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>The keyword <code class="highlight coq"><span class="n">function_properties</span></code> works exactly like <code class="highlight coq"><span class="n">def</span></code> with annotations
but you do not provide the function definition <code class="highlight coq"><span class="o">:=</span> <span class="o">...</span></code>. Argument types 
and order have to match exactly the original definition but the argument 
names do not have to be the same.</p>
<div class="section" id="multiple-arguments">
<h2>Multiple Arguments</h2>
<p>(TODO: Explain how annotations work with multiple arguments. The current
behavior is a bit limiting, so I should rewrite how they work before 
I write this section.)</p>
</div>
<div class="section" id="how-do-annotations-work">
<h2>How Do Annotations Work?</h2>
<p>The <code class="highlight coq"><span class="n">isSmooth</span></code> and <code class="highlight coq"><span class="n">diff</span></code> annotations might appear misterious but they
are simple macros.</p>
<p>This definition</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kd">def</span> cube (x : ℝ) : ℝ := x <span class="bp">*</span> x <span class="bp">*</span> x
argument x
  isSmooth :=</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk55"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmooth <span class="k">fun</span> x <span class="bp">=&gt;</span> cube x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk56">unfold cube</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmooth <span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">*</span> x <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk57">infer_instance</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span><span class="alectryon-wsp">,
  diff := <span class="mi">3</span> <span class="bp">*</span> dx <span class="bp">*</span> x <span class="bp">*</span> x <span class="kd">by</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk58">simp[diff,cube]</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x dx <span class="bp">=&gt;</span> (dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx) <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> x <span class="bp">*</span> dx) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> <span class="mi">3</span> <span class="bp">*</span> dx <span class="bp">*</span> x <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk59">funext x dx</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, dx</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.h</span></span><div class="goal-conclusion">(dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx) <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> x <span class="bp">*</span> dx <span class="bp">=</span> <span class="mi">3</span> <span class="bp">*</span> dx <span class="bp">*</span> x <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk5a">ring</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>Is unfolded to (we have to use a new identifier <code class="highlight coq"><span class="n">cube_v1</span></code> as <code class="highlight coq"><span class="n">cube</span></code> is 
already defined)</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kd">def</span> cube_v1 (x : ℝ) : ℝ := x <span class="bp">*</span> x <span class="bp">*</span> x

<span class="c1">-- proof of smoothness</span>
<span class="kd">instance</span> cube_v1.arg_x.isSmooth : IsSmooth (<span class="bp">λ</span> x <span class="bp">=&gt;</span> cube_v1 x) := 
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk5b"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmooth <span class="k">fun</span> x <span class="bp">=&gt;</span> cube_v1 x</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk5c">unfold cube_v1</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">IsSmooth <span class="k">fun</span> x <span class="bp">=&gt;</span> x <span class="bp">*</span> x <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk5d">infer_instance</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c1">-- differential definition</span>
<span class="kd">def</span> cube_v1.arg_x.diff (x dx : ℝ) : ℝ := <span class="mi">3</span> <span class="bp">*</span> dx <span class="bp">*</span> x <span class="bp">*</span> x

<span class="c1">-- simplifier rule</span>
<span class="kd">@[simp]</span>
<span class="kd">theorem</span> cube_v1.arg_x.diff_simp 
  : <span class="bp">∂</span> cube_v1 <span class="bp">=</span> cube_v1.arg_x.diff :=
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk5e"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂</span>cube_v1 <span class="bp">=</span> diff</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk5f">simp[diff,cube_v1]</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="k">fun</span> x dx <span class="bp">=&gt;</span> (dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx) <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> x <span class="bp">*</span> dx) <span class="bp">=</span> <span class="k">fun</span> x dx <span class="bp">=&gt;</span> <span class="mi">3</span> <span class="bp">*</span> dx <span class="bp">*</span> x <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk60">funext x dx</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, dx</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr><span class="goal-name">h.h</span></span><div class="goal-conclusion">(dx <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> dx) <span class="bp">*</span> x <span class="bp">+</span> x <span class="bp">*</span> x <span class="bp">*</span> dx <span class="bp">=</span> <span class="mi">3</span> <span class="bp">*</span> dx <span class="bp">*</span> x <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk61">ring</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>Using <code class="highlight coq"><span class="n">diff_simp</span></code> annotation does not define <code class="highlight coq"><span class="n">cube_v1</span><span class="o">.</span><span class="n">arg_x</span><span class="o">.</span><span class="n">diff</span></code> and 
the simp theorem states directly <code class="highlight coq"><span class="o">∂</span> <span class="n">cube_v1</span> <span class="o">=</span> <span class="kr">λ</span> <span class="nv">x</span> <span class="nv">dx</span> <span class="o">=&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span></code>.</p>
</div>
</div>
<div class="section" id="adjoint-differential">
<h1>Adjoint Differential</h1>
<p>Finding the minimum of a function <code class="highlight coq"><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="o">→</span> <span class="n">ℝ</span></code> with gradient descent 
requires function's gradient <code class="highlight coq"><span class="o">∇</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="o">→</span> <span class="n">X</span></code>.</p>
<p>However, can we compute the gradient just with the differential <code class="highlight coq"><span class="o">∂</span></code>? 
No we can't! We need an adjoint <code class="highlight coq"><span class="o">†</span></code> too!</p>
<p>The differential <code class="highlight coq"><span class="o">∂</span> <span class="n">f</span> <span class="n">x</span></code> at point <code class="highlight coq"><span class="n">x</span></code> is a linear function <code class="highlight coq"><span class="n">X</span> <span class="o">→</span> <span class="n">R</span></code>.
When we take an adjoint and apply one we get an element of <code class="highlight coq"><span class="n">X</span></code>. That 
is the gradient of <code class="highlight coq"><span class="n">f</span></code> at <code class="highlight coq"><span class="n">x</span></code>!</p>
<p>In finite dimension, we can think about differential <code class="highlight coq"><span class="o">∂</span> <span class="n">f</span> <span class="n">x</span></code> is a row vector.
To get a column vector we have to transpose it i.e. take its adjoint.</p>
<p>For general function <code class="highlight coq"><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="o">→</span> <span class="n">Y</span></code>, we define adjoint differential 
<code class="highlight coq"><span class="o">∂†</span> <span class="o">:</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">→</span> <span class="o">(</span><span class="n">X</span> <span class="o">→</span> <span class="n">Y</span> <span class="o">→</span> <span class="n">X</span><span class="o">)</span></code> as <code class="highlight coq"><span class="o">∂†</span> <span class="n">f</span> <span class="n">x</span> <span class="n">dy</span> <span class="o">:=</span> <span class="o">(∂</span> <span class="n">f</span> <span class="n">x</span><span class="o">)†</span> <span class="n">dy</span></code></p>
<p>Taking adjoint makes sense only for functions between Hilberts spaces.
Let's introduce few of those</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kn">section</span> AdjointDifferential

  <span class="kd">variable</span> {X Y Z} [Hilbert X] [Hilbert Y] [Hilbert Z]</span></pre><p>To stress the definition of adjoint differential</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">example</span> (f : X <span class="bp">→</span> Y) : <span class="bp">∂†</span> f <span class="bp">=</span> <span class="bp">λ</span> x dy <span class="bp">=&gt;</span> (<span class="bp">∂</span> f x)<span class="bp">†</span> dy :=</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk62"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.46804</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∂†</span>f <span class="bp">=</span> <span class="k">fun</span> x dy <span class="bp">=&gt;</span> adjoint (differential f x) dy</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk63">rfl</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>Similarly to derivative <code class="highlight coq"><span class="n">ⅆ</span></code>, we define a specialized operator gradient <code class="highlight coq"><span class="o">∇</span></code>
for real valued functions over any Hilbert space</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">example</span> (f : X <span class="bp">→</span> ℝ) : <span class="bp">∇</span> f <span class="bp">=</span> <span class="bp">λ</span> x <span class="bp">=&gt;</span> (<span class="bp">∂</span> f x)<span class="bp">†</span> <span class="mi">1</span> :=</span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk64"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.46940</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.46943</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∇</span>f <span class="bp">=</span> <span class="k">fun</span> x <span class="bp">=&gt;</span> adjoint (differential f x) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk65">rfl</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>The important result is that the gradient of squared norm <code class="highlight coq"><span class="o">∥</span><span class="n">x</span><span class="o">∥²</span></code> is <code class="highlight coq"><span class="mi">2</span><span class="o">*</span><span class="n">x</span></code></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk66"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">AutoImpl.val (Eq.mpr (_ : (AutoImpl <span class="bp">∇</span><span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="bp">∥</span>x<span class="bp">∥²</span>) <span class="bp">=</span> AutoImpl <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> x) AutoImpl.finish) : X <span class="bp">→</span> X</blockquote></div></div></small></span><span class="alectryon-wsp"> (<span class="bp">∇</span> (x : X), <span class="bp">∥</span>x<span class="bp">∥²</span>) 
    rewrite_by 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk67">(</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47097</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47100</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∇</span><span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="bp">∥</span>x<span class="bp">∥²</span></div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk68">simp[gradient,hold]</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47097</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47100</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk69">trace_state</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">X : <span class="kt">Type</span>
Y : <span class="kt">Type</span> <span class="bp">?</span>u.47097
Z : <span class="kt">Type</span> <span class="bp">?</span>u.47100
inst<span class="bp">✝²</span> : SciLean.Hilbert X
inst<span class="bp">✝¹</span> : SciLean.Hilbert Y
inst<span class="bp">✝</span> : SciLean.Hilbert Z
<span class="bp">|</span> <span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> x</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47097</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47100</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> x</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="differentiation-in-scilean-lean-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk6a">)</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47097</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47100</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝¹</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> x</div></blockquote></div></div></small></span></pre><p>(TODO: Make sure we do not need to unfold gradient and hold here`)</p>
<p>Another fun result is that the gradient of <code class="highlight coq"><span class="o">⟪</span><span class="n">A</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">⟫</span></code> is <code class="highlight coq"><span class="o">(</span><span class="n">A</span><span class="o">†</span> <span class="o">+</span> <span class="n">A</span><span class="o">)</span> <span class="n">x</span></code></p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">variable</span> (A : X <span class="bp">→</span> X) [HasAdjDiff A] [IsLin A]

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk6b"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">AutoImpl.val
  (Eq.mpr (_ : (AutoImpl <span class="bp">∇</span><span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="bp">⟪</span>A x, x<span class="bp">⟫</span>) <span class="bp">=</span> AutoImpl <span class="k">fun</span> x <span class="bp">=&gt;</span> adjoint (<span class="k">fun</span> x <span class="bp">=&gt;</span> A x) x <span class="bp">+</span> A x)
    AutoImpl.finish) : X <span class="bp">→</span> X</blockquote></div></div></small></span><span class="alectryon-wsp"> (<span class="bp">∇</span> x, <span class="bp">⟪</span>A x, x<span class="bp">⟫</span>) 
    rewrite_by 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk6c">(</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47438</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47441</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝³</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="bp">∇</span><span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="bp">⟪</span>A x, x<span class="bp">⟫</span></div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk6d">simp[gradient,hold,adjointDifferential]</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47438</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47441</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝³</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x <span class="bp">=&gt;</span> adjoint (<span class="k">fun</span> x <span class="bp">=&gt;</span> A x) x <span class="bp">+</span> A x</div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="bp">;</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk6e">trace_state</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">X : <span class="kt">Type</span>
Y : <span class="kt">Type</span> <span class="bp">?</span>u.47438
Z : <span class="kt">Type</span> <span class="bp">?</span>u.47441
inst<span class="bp">✝⁴</span> : SciLean.Hilbert X
inst<span class="bp">✝³</span> : SciLean.Hilbert Y
inst<span class="bp">✝²</span> : SciLean.Hilbert Z
A : X <span class="bp">→</span> X
: SciLean.HasAdjDiff A
: SciLean.IsLin A
<span class="bp">|</span> <span class="k">fun</span> x <span class="bp">=&gt;</span> SciLean.adjoint (<span class="k">fun</span> x <span class="bp">=&gt;</span> A x) x <span class="bp">+</span> A x</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47438</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47441</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝³</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x <span class="bp">=&gt;</span> adjoint (<span class="k">fun</span> x <span class="bp">=&gt;</span> A x) x <span class="bp">+</span> A x</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="differentiation-in-scilean-lean-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk6f">)</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>Y</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47438</span></span></span><br><span><var>Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span> <span class="bp">?</span>u.47441</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝³</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝²</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="k">fun</span> x <span class="bp">=&gt;</span> adjoint (<span class="k">fun</span> x <span class="bp">=&gt;</span> A x) x <span class="bp">+</span> A x</div></blockquote></div></div></small></span></pre><p>(TODO: Ughh, this requires too many assumptions on A and too many unfolding`)</p>
<p>Similar to chain rule for differential, we have a chain rule for the adjoint 
differential but the composition is in reverse</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">variable</span> (f : Y <span class="bp">→</span> Z) [HasAdjDiff f]
  <span class="kd">variable</span> (g : X <span class="bp">→</span> Y) [HasAdjDiff g]

  <span class="kd">example</span> : (<span class="bp">∂†</span> <span class="bp">λ</span> x <span class="bp">=&gt;</span> f (g x)) <span class="bp">=</span> (<span class="bp">λ</span> x dz <span class="bp">=&gt;</span> <span class="bp">∂†</span> g x (<span class="bp">∂†</span> f (g x) dz)) := 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk70"><span class="kd">by</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝⁵</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝⁴</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="bp">∂†</span><span class="k">fun</span> x <span class="bp">=&gt;</span> f (g x)) <span class="bp">=</span> <span class="k">fun</span> x dz <span class="bp">=&gt;</span> adjointDifferential g x (adjointDifferential f (g x) dz)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk71">simp</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Goals accomplished<span class="bp">!</span> <span class="bp">🐙</span></div></blockquote></div></div></small></span></pre><p>(TODO: Explain what <code class="highlight coq"><span class="n">HasAdjDiff</span> <span class="n">f</span></code> is)</p>
<div class="section" id="euler-lagrange-equations">
<h2>Euler-Lagrange Equations</h2>
<p>Let's write down Euler-Lagrange equations to demonstrate SciLean's notation
in a bit complicated scenario.</p>
<p>They are usally written in the following way</p>
<div class="math">
\begin{equation*}
\frac{d}{dt} \frac{\partial}{\partial \dot x} L(x(t),\dot x(t)) - \frac{\partial}{\partial x} L(x(t),\dot x(t)) = 0
\end{equation*}
</div>
<p>However, the partial derivative notation is really ambigous. Thus a bit
more explicit form is</p>
<div class="math">
\begin{equation*}
\frac{d}{ds}\bigg\rvert_{s=t} \frac{\partial}{\partial v}\bigg\rvert_{v=\dot y(s)} L(y(s),v) - \frac{\partial}{\partial x}\bigg\rvert_{x=y(t)} L(x, \dot y(t)) = 0
\end{equation*}
</div>
<p>And this form can be written in SciLean relativelly nicely.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">variable</span> (L : X <span class="bp">→</span> X <span class="bp">→</span> ℝ)  <span class="c1">-- Lagrangian </span>
  <span class="kd">variable</span> (y : ℝ <span class="bp">→</span> X)      <span class="c1">-- trajectory </span>
  <span class="kd">variable</span> (t : ℝ)          <span class="c1">-- time</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk72"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">derivative <span class="mi">1</span> (<span class="k">fun</span> s <span class="bp">=&gt;</span> gradient (<span class="k">fun</span> v <span class="bp">=&gt;</span> L (y s) v) (derivative <span class="mi">1</span> y s)) t <span class="bp">-</span>
    gradient (<span class="k">fun</span> x <span class="bp">=&gt;</span> L x (derivative <span class="mi">1</span> y t)) (y t) <span class="bp">=</span>
  <span class="mi">0</span> : <span class="kt">Prop</span></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    ⅆ (s:=t), <span class="bp">∇</span> (v:=ⅆ y s), L (y s) v <span class="bp">-</span> <span class="bp">∇</span> (x:=y t), L x (ⅆ y t) <span class="bp">=</span> <span class="mi">0</span></span></pre><p>Let's plug in a Lagrangian for a particle in a potential field and hopefully 
we get the correct equations of motion.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">  <span class="kd">def</span> L&#39; (ϕ : X <span class="bp">→</span> ℝ) (m : ℝ) (x v : X) := <span class="mi">1</span><span class="bp">/</span><span class="mi">2</span><span class="bp">*</span>m<span class="bp">*∥</span>v<span class="bp">∥²</span> <span class="bp">-</span> ϕ x

  <span class="kd">variable</span> [IsSmooth y]  <span class="c1">-- trajectory is smooth</span>
  <span class="kd">variable</span> (ϕ : X <span class="bp">→</span> ℝ)  [HasAdjDiff ϕ]
  <span class="kd">variable</span> (m : ℝ) <span class="c1">-- mass</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk73"><span class="k">#check</span></label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">AutoImpl.val
  (Eq.mpr
    (_ :
      AutoImpl
          (derivative <span class="mi">1</span> (<span class="k">fun</span> s <span class="bp">=&gt;</span> gradient (<span class="k">fun</span> v <span class="bp">=&gt;</span> L&#39; ϕ m (y s) v) (derivative <span class="mi">1</span> y s)) t <span class="bp">-</span>
            gradient (<span class="k">fun</span> x <span class="bp">=&gt;</span> L&#39; ϕ m x (derivative <span class="mi">1</span> y t)) (y t)) <span class="bp">=</span>
        AutoImpl
          (instDerivativeForAllℝ.dn <span class="mi">1</span> (<span class="k">fun</span> s <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> (<span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span>) <span class="bp">*</span> m <span class="bp">*</span> instDerivativeForAllℝ.dn <span class="mi">1</span> y s) t <span class="bp">-</span>
            adjointDifferential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) (y t) (<span class="bp">-</span><span class="mi">1</span>)))
    AutoImpl.finish) : X</blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    (ⅆ (s:=t), <span class="bp">∇</span> (v:=ⅆ y s), L&#39; ϕ m (y s) v 
     <span class="bp">-</span> 
     <span class="bp">∇</span> (x:=y t), L&#39; ϕ m x (ⅆ y t))
    rewrite_by 
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk74">(</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁸</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X <span class="bp">→</span> ℝ</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> ℝ</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">derivative <span class="mi">1</span> (<span class="k">fun</span> s <span class="bp">=&gt;</span> gradient (<span class="k">fun</span> v <span class="bp">=&gt;</span> L&#39; ϕ m (y s) v) (derivative <span class="mi">1</span> y s)) t <span class="bp">-</span>
  gradient (<span class="k">fun</span> x <span class="bp">=&gt;</span> L&#39; ϕ m x (derivative <span class="mi">1</span> y t)) (y t)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk75">simp[L&#39;]</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁸</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X <span class="bp">→</span> ℝ</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> ℝ</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">derivative <span class="mi">1</span> (<span class="k">fun</span> s <span class="bp">=&gt;</span> gradient (<span class="k">fun</span> v <span class="bp">=&gt;</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">*</span> m <span class="bp">*</span> <span class="bp">∥</span>v<span class="bp">∥²</span> <span class="bp">-</span> ϕ (y s)) (derivative <span class="mi">1</span> y s)) t <span class="bp">-</span>
  gradient (<span class="k">fun</span> x <span class="bp">=&gt;</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">*</span> m <span class="bp">*</span> <span class="bp">∥</span>derivative <span class="mi">1</span> y t<span class="bp">∥²</span> <span class="bp">-</span> ϕ x) (y t)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk76">simp[gradient,hold]</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁸</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X <span class="bp">→</span> ℝ</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> ℝ</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">derivative <span class="mi">1</span> (<span class="k">fun</span> s <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> (<span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span>) <span class="bp">*</span> m <span class="bp">*</span> derivative <span class="mi">1</span> y s) t <span class="bp">-</span> adjointDifferential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) (y t) (<span class="bp">-</span><span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk77">simp[derivative]</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁸</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X <span class="bp">→</span> ℝ</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> ℝ</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">instDerivativeForAllℝ.dn <span class="mi">1</span> (<span class="k">fun</span> s <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> (<span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span>) <span class="bp">*</span> m <span class="bp">*</span> instDerivativeForAllℝ.dn <span class="mi">1</span> y s) t <span class="bp">-</span>
  adjointDifferential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) (y t) (<span class="bp">-</span><span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="differentiation-in-scilean-lean-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk78">trace_state</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">X Y Z : <span class="kt">Type</span>
inst<span class="bp">✝⁸</span> : SciLean.Hilbert X
inst<span class="bp">✝⁷</span> : SciLean.Hilbert Y
inst<span class="bp">✝⁶</span> : SciLean.Hilbert Z
A : X <span class="bp">→</span> X
: SciLean.HasAdjDiff A
: SciLean.IsLin A
f : Y <span class="bp">→</span> Z
: SciLean.HasAdjDiff f
g : X <span class="bp">→</span> Y
: SciLean.HasAdjDiff g
L : X <span class="bp">→</span> X <span class="bp">→</span> ℝ
y : ℝ <span class="bp">→</span> X
t : ℝ
: SciLean.IsSmooth y
ϕ : X <span class="bp">→</span> ℝ
: SciLean.HasAdjDiff ϕ
m : ℝ
<span class="bp">|</span> SciLean.instDerivativeForAllℝ.dn <span class="mi">1</span> (<span class="k">fun</span> s <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> (<span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span>) <span class="bp">*</span> m <span class="bp">*</span> SciLean.instDerivativeForAllℝ.dn <span class="mi">1</span> y s) t <span class="bp">-</span>
    SciLean.adjointDifferential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) (y t) (<span class="bp">-</span><span class="mi">1</span>)</blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁸</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X <span class="bp">→</span> ℝ</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> ℝ</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">instDerivativeForAllℝ.dn <span class="mi">1</span> (<span class="k">fun</span> s <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> (<span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span>) <span class="bp">*</span> m <span class="bp">*</span> instDerivativeForAllℝ.dn <span class="mi">1</span> y s) t <span class="bp">-</span>
  adjointDifferential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) (y t) (<span class="bp">-</span><span class="mi">1</span>)</div></blockquote></div></div></small></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="differentiation-in-scilean-lean-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="differentiation-in-scilean-lean-chk79">)</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>X, Y, Z</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>inst✝⁸</var><span class="hyp-type"><b>: </b><span>Hilbert X</span></span></span><br><span><var>inst✝⁷</var><span class="hyp-type"><b>: </b><span>Hilbert Y</span></span></span><br><span><var>inst✝⁶</var><span class="hyp-type"><b>: </b><span>Hilbert Z</span></span></span><br><span><var>A</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>Y <span class="bp">→</span> Z</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> Y</span></span></span><br><span><var>L</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> X <span class="bp">→</span> ℝ</span></span></span><br><span><var>y</var><span class="hyp-type"><b>: </b><span>ℝ <span class="bp">→</span> X</span></span></span><br><span><var>t</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br><span><var>ϕ</var><span class="hyp-type"><b>: </b><span>X <span class="bp">→</span> ℝ</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>ℝ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">instDerivativeForAllℝ.dn <span class="mi">1</span> (<span class="k">fun</span> s <span class="bp">=&gt;</span> <span class="mi">2</span> <span class="bp">*</span> (<span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span>) <span class="bp">*</span> m <span class="bp">*</span> instDerivativeForAllℝ.dn <span class="mi">1</span> y s) t <span class="bp">-</span>
  adjointDifferential (<span class="k">fun</span> x <span class="bp">=&gt;</span> ϕ x) (y t) (<span class="bp">-</span><span class="mi">1</span>)</div></blockquote></div></div></small></span></pre><p>(TODO: Make sure we get these rewrite to make the result look nicer</p>
<blockquote>
<p><code class="highlight coq"><span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">)</span> <span class="o">=</span> <span class="mi">1</span></code></p>
<p><code class="highlight coq"><span class="n">differential</span> <span class="o">(∂</span><span class="n">y</span><span class="o">)</span> <span class="n">t</span> <span class="mi">1</span> <span class="mi">1</span> <span class="o">=</span> <span class="n">ⅆ</span> <span class="o">(</span><span class="n">ⅆ</span> <span class="n">y</span><span class="o">)</span> <span class="n">t</span></code></p>
<p><code class="highlight coq"><span class="n">adjointDifferential</span> <span class="o">(</span><span class="kr">fun</span> <span class="nv">x</span> <span class="o">=&gt;</span> <span class="n">ϕ</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="n">t</span><span class="o">)</span> <span class="o">(-</span><span class="mi">1</span><span class="o">)</span> <span class="o">=</span> <span class="o">-</span> <span class="o">∇</span> <span class="n">ϕ</span> <span class="o">(</span><span class="n">y</span> <span class="n">t</span><span class="o">)</span></code>)</p>
</blockquote>
<p>The result is (with the TODO rewrites) <code class="highlight coq"><span class="n">m</span> <span class="o">*</span> <span class="n">ⅆ</span> <span class="o">(</span><span class="n">ⅆ</span> <span class="n">y</span><span class="o">)</span> <span class="n">t</span> <span class="o">+</span> <span class="o">∇</span> <span class="n">ϕ</span> <span class="o">(</span><span class="n">y</span> <span class="n">t</span><span class="o">)</span></code> which 
exacly corresponts to the equation of a particle in a potential field <code class="highlight coq"><span class="n">ϕ</span></code></p>
<div class="math">
\begin{equation*}
m \ddot y(t) = - \nabla \phi (y(t))
\end{equation*}
</div>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="kd">end</span> AdjointDifferential</span></pre></div>
</div>
</div>
</div></body>
</html>
